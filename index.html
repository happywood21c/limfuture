<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>일본 날씨 3일 예보</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 0;
      padding: 20px;
      background: linear-gradient(to bottom, #dbeafe, #ffffff);
    }
    h1 {
      text-align: center;
      margin-bottom: 24px;
    }
    .city-card {
      background: white;
      border-radius: 16px;
      padding: 16px;
      margin-bottom: 20px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }
    .city-name {
      font-size: 18px;
      font-weight: bold;
      margin-bottom: 8px;
    }
    .forecast-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .forecast-item {
      text-align: center;
      flex: 1;
    }
    .icon {
      width: 48px;
      height: 48px;
    }
    .date {
      font-size: 12px;
      color: #555;
    }
    .temp-range {
      font-size: 13px;
      color: #333;
    }
  </style>
</head>
<body>
  <h1>일본 날씨 (3일 예보)</h1>
  <div id="weather-container"></div>

  <script>
    const apiKey = 'YOUR_API_KEY'; // ← OpenWeatherMap API 키 입력
    const cities = [
      { name: '오카야마 (다카하시 인근)', id: 1854383 },
      { name: '우츠노미야 (모카 인근)', id: 1849053 },
      { name: '나메가타', id: 1855612 }
    ];

    async function fetchForecast(city) {
      const url = `https://api.openweathermap.org/data/2.5/forecast?id=${city.id}&appid=${apiKey}&units=metric&lang=kr`;
      const res = await fetch(url);
      if (!res.ok) throw new Error(`${city.name} 요청 실패`);
      const data = await res.json();
      return processForecastData(data);
    }

    function processForecastData(data) {
      const daily = {};
      data.list.forEach(item => {
        const date = item.dt_txt.split(' ')[0];
        if (!daily[date]) daily[date] = [];

        daily[date].push(item);
      });

      const sortedDates = Object.keys(daily).slice(0, 3);

      return sortedDates.map(date => {
        const items = daily[date];
        const temps = items.map(i => i.main.temp);
        const minTemp = Math.min(...temps);
        const maxTemp = Math.max(...temps);

        const icon = items[4]?.weather[0].icon || items[0].weather[0].icon;
        const desc = items[4]?.weather[0].description || items[0].weather[0].description;

        return {
          date,
          icon,
          desc,
          min: Math.round(minTemp),
          max: Math.round(maxTemp)
        };
      });
    }

    async function renderForecast() {
      const container = document.getElementById('weather-container');
      for (const city of cities) {
        try {
          const forecasts = await fetchForecast(city);
          const cityCard = document.createElement('div');
          cityCard.className = 'city-card';
          cityCard.innerHTML = `<div class="city-name">${city.name}</div>`;

          const row = document.createElement('div');
          row.className = 'forecast-row';

          forecasts.forEach(f => {
            const item = document.createElement('div');
            item.className = 'forecast-item';
            item.innerHTML = `
              <div class="date">${f.date}</div>
              <img class="icon" src="https://openweathermap.org/img/wn/${f.icon}@2x.png" alt="icon" />
              <div class="desc">${f.desc}</div>
              <div class="temp-range">${f.min}° ~ ${f.max}°C</div>
            `;
            row.appendChild(item);
          });

          cityCard.appendChild(row);
          container.appendChild(cityCard);
        } catch (err) {
          console.error(err.message);
        }
      }
    }

    renderForecast();
  </script>
</body>
</html>
